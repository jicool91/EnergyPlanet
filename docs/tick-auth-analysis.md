# Анализ авторизации `/tick` и управления пассивным доходом

_Дата: 26 октября 2025_

## Наблюдения по логам
- Последние логи (`2025-10-26 12:55–13:48 UTC`) показывают, что **до** получения токена приходят одиночные `auth_missing_header` / `auth_unexpected_error (401)` на `POST /api/v1/tick`, `GET /api/v1/leaderboard`, `GET /api/v1/prestige`.
- После вызова `POST /api/v1/auth/telegram` и `POST /api/v1/session` тик начинает отрабатывать **успешно (200)** с интервалом ~10–20 секунд.
- Когда вкладка скрывается или закрывается, при следующем старте снова происходит `/auth/telegram` → `/session` → тик, что повторяет стартовый цикл.

## Найденные проблемы
1. **Лишний шум в логах**: каждое обращение `/tick` логируется как `info`. При 10⁵–10⁶ пользователей это приведёт к огромному объёму логов/стоимости.
2. **Накопление пассивки** сейчас происходит только в браузере (`pendingPassiveSeconds`). Пока токен не получен, фронт всё равно пытается отправить тик → ловим 401 и тратим ресурсы.
3. **Авторизация всегда через `/auth/telegram`**. Даже повторные заходы стихают initData заново, хотя Telegram рекомендует использовать refresh-токен.

## Best Practices (на основе Telegram docs и кейсов других Mini Apps)
- **Авторизация**:
  - Использовать связку `access + refresh`. При запуске:
    1. Берём токены из localStorage.
    2. Если `access` жив — сразу работаем.
    3. Если нет — пробуем `/auth/refresh`.
    4. Только если refresh истёк → `/auth/telegram`.
  - Можно кешировать `hash(initData)` и сравнивать при следующем старте, чтобы реже тянуть initData.
- **Пассивка и тик**:
  - Не слать `/tick`, пока нет валидного токена (копить секунды локально).
  - При `visibilitychange` ставить flush на паузу и возобновлять одним запросом при возвращении вкладки.
  - Для оффлайна полагаться на `/session`, который возвращает накопленные награды.
- **Логирование**:
  - Перевести `POST /api/v1/tick` в `debug`.
  - Оставить `warn`/`error` только для аномалий (`auth_missing_header`, `invalid_token`, `tick_skip_unauthenticated`).

## Предложенные варианты решения

### Вариант A — «консервативный»
1. Перед `flushPassiveIncome` жёстко проверять флаг `authReady`.
2. Останавливать интервалы тика, когда вкладка скрыта; запускать разовый тик при возвращении.
3. Логи `/tick` перевести в `debug`, оставить `warn` для ошибок авторизации.

### Вариант B — «гибрид с initData»
1. Разрешить **первый** тик без JWT, но с заголовком `Authorization: TelegramInit <raw initData>`:
   - Бэкенд валидирует подпись initData (через `@telegram-apps/init-data-node`).
   - Сразу выдаёт новые `access/refresh` токены и выполняет тик.
2. После этого клиент работает по обычной схеме `Bearer`.
3. Также добавить паузы/хранение пассивки как в варианте A.

## Следующие шаги
- Определиться: достаточно ли варианта A (меньше изменений) или нужна мгновенная обработка initData (вариант B).
- Независимо от выбранного варианта:
  - Переквалифицировать логи `/tick` в `debug`.
  - Доделать на фронте блокировку flush, пока не получен токен.
  - Настроить повторный flush сразу после `authReady`, чтобы не терять накопленное время.

## Расширенный контекст Telegram Mini App
- Игра работает исключительно как Telegram Mini App, поэтому **initData** от Telegram Web App — единственный источник короткоживущих подписанных данных. Обязательна проверка подписи через HMAC-SHA256 и контроль `auth_date ≤ 300 секунд`, иначе Telegram может заморозить бота.
- Коммьюнити Mini App и официальные SDK рекомендуют выдавать **собственные JWT/сессии** после первой валидации `initData`, чтобы не обращаться к Telegram при каждом старте вкладки. Основа — пара access (≈15 минут) + refresh (7–30 дней) с ротацией на каждое использование.
- Refresh-токены безопаснее хранить в HttpOnly Secure SameSite=Lax cookie, а access держать в памяти SPA. Это снижает риск XSS и не требует localStorage.
- Пассивный доход должен начисляться на сервере по `last_tick_at`, чтобы игрок не терял оффлайн-награждения и нельзя было накрутить секунды клиентом.

## Производственные риски при 100 000 активных игроков
- **Шторм 401**: без стартовой авторизации до 100 к клиентов разом будут спамить `/tick` → 401, что перегрузит API и нарушит SLO.
- **Стоимость логов**: при интервале 10–20 с это 5–6 к RPS; текущие INFO-логи `/tick` сожгут бюджет и размоют нужные сигналы.
- **Потеря пассивки**: хранение секунд только в браузере ⇒ любое падение окна/сессии уничтожает прогресс игрока.
- **Отсутствие rate-limit**: баг или злоумышленник может мультиплицировать `/tick`, сжигая ресурсы и сбивая экономику.
- **Наблюдаемость**: без метрик и алертов нельзя быстро заметить деградацию авторизации/тика.

## План внедрения (production-ready)
1. **Архитектура авторизации**
   - Добавить `POST /api/v1/auth/tma`: принимает `Authorization: tma <raw initData>`, валидирует подпись/`auth_date`, кеширует `hash(initData)` на 5 минут для анти-replay, выдаёт access+refresh.
   - Реализовать `/api/v1/auth/refresh` с ротацией refresh-токена, хранить хеши refresh в БД и помечать устройства (`auth_session_id`).
   - Middleware: проверка Bearer → device scope → допуск. При истекшем access — 401 с кодом `TOKEN_EXPIRED`, чтобы фронт знал, что пора рефрешить.
2. **Фронтенд**
   - Ввести состояния `authReady`, `pendingPassiveSeconds`, `authSessionId`. Блокировать `flushPassiveIncome`, пока токен не готов, и отправлять накопленные секунды одной порцией после авторизации.
   - Стартовая цепочка: `silentRefresh()` → при успехе запуск `tick` → при 401 попытка `tmaAuth()` → повторный запуск.
   - Управление жизненным циклом: на `visibilitychange` и `pagehide` останавливать интервал тика; на `focus` отправлять разовый catch-up тик и перезапускать.
3. **Backend `/tick`**
   - Перенести расчёт пассивного дохода на сервер: хранить `last_tick_at`, `accrued_passive`, использовать серверное время.
   - Оградить `/tick` лёгким rate-limit (1 запрос / 8 секунд на игрока) и быстрым отказом `429`.
   - Разрешить cold-start тик с `Authorization: tma …`, который одновременно валидирует initData, выдаёт токены и исполняет тик.
4. **Наблюдаемость и логирование**
   - Перевести успешные `/tick` в `debug` + sampling (1–5 %). Ошибки `auth_missing_header`, `invalid_token`, rate-limit — `warn`.
   - Ввести метрики: счётчики `tick_success`, `tick_unauth`, `refresh_fail`, `tma_reused`; гистограммы латентности.
   - Настроить алерты: доля 401 > 1 %, p95 латентности > 200 мс, всплеск `tma_reused`.
5. **Масштабирование и тесты**
   - k6/Gatling: холодный старт 100 к клиентов, steady-state 600 RPS, массовый disconnect/reconnect.
   - Проверка пулов Postgres/Redis, настройка горизонтального масштабирования.
   - Canary rollout 5 % → 25 % → 100 % с обратным каналом метрик.

## Бэклог задач
### Backend
1. `BE-01` Реализовать `POST /api/v1/auth/tma` (валидация подписи, кеш хеша, выдача токенов).
2. `BE-02` Добавить `/api/v1/auth/refresh`, таблицу refresh-токенов и ротацию.
3. `BE-03` Переработать `/api/v1/tick`: серверный расчёт пассивки, идемпотентность, rate-limit, поддержка cold-start `tma`.
4. `BE-04` Миграция `player_sessions` (`player_id`, `auth_session_id`, `last_tick_at`, `accrued_passive`, `refresh_hash`, аудиты).
5. `BE-05` Перенастроить логирование `/tick` (debug + sampling), добавить метрики и алерты.

### Frontend
1. `FE-01` Ввести стор `authReady`, `pendingPassiveSeconds`, `authSessionId`; блокировка flush без токена.
2. `FE-02` Реализовать `useAuthBootstrap` (silent refresh → tma fallback) и обновить API-сервисы (`auth/tma`, `auth/refresh`).
3. `FE-03` Обновить `useTickLoop`: пауза на `visibilitychange`, catch-up тик при `focus`, единичный flush после авторизации.
4. `FE-04` Добавить тесты (unit/e2e) для cold-start, expiry refresh, скрытия вкладки и race-сценариев.

### Infra / Observability
1. `OPS-01` Настроить log sampling/фильтры на `/tick`, перевод экспорта в структурированный формат.
2. `OPS-02` Создать дашборды и алерты (tick success, 401 rate, латентность, tma replay).
3. `OPS-03` Подготовить нагрузочные тесты (k6/Gatling) и включить их в CI.
4. `OPS-04` Настроить canary-развёртывание + процедуру rollback, описать runbook.

### QA / Security
1. `QA-01` Обновить чек-листы: холодный старт, оффлайн, параллельные вкладки, rate-limit.
2. `SEC-01` Смоделировать атаки (replay initData, brute-force refresh), описать ожидания и контрмеры.
