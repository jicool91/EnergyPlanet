# Анализ авторизации `/tick` и управления пассивным доходом

_Дата: 26 октября 2025_

## Наблюдения по логам
- Последние логи (`2025-10-26 12:55–13:48 UTC`) показывают, что **до** получения токена приходят одиночные `auth_missing_header` / `auth_unexpected_error (401)` на `POST /api/v1/tick`, `GET /api/v1/leaderboard`, `GET /api/v1/prestige`.
- После вызова `POST /api/v1/auth/telegram` и `POST /api/v1/session` тик начинает отрабатывать **успешно (200)** с интервалом ~10–20 секунд.
- Когда вкладка скрывается или закрывается, при следующем старте снова происходит `/auth/telegram` → `/session` → тик, что повторяет стартовый цикл.

## Найденные проблемы
1. **Лишний шум в логах**: каждое обращение `/tick` логируется как `info`. При 10⁵–10⁶ пользователей это приведёт к огромному объёму логов/стоимости.
2. **Накопление пассивки** сейчас происходит только в браузере (`pendingPassiveSeconds`). Пока токен не получен, фронт всё равно пытается отправить тик → ловим 401 и тратим ресурсы.
3. **Авторизация всегда через `/auth/telegram`**. Даже повторные заходы стихают initData заново, хотя Telegram рекомендует использовать refresh-токен.

## Best Practices (на основе Telegram docs и кейсов других Mini Apps)
- **Авторизация**:
  - Использовать связку `access + refresh`. При запуске:
    1. Берём токены из localStorage.
    2. Если `access` жив — сразу работаем.
    3. Если нет — пробуем `/auth/refresh`.
    4. Только если refresh истёк → `/auth/telegram`.
  - Можно кешировать `hash(initData)` и сравнивать при следующем старте, чтобы реже тянуть initData.
- **Пассивка и тик**:
  - Не слать `/tick`, пока нет валидного токена (копить секунды локально).
  - При `visibilitychange` ставить flush на паузу и возобновлять одним запросом при возвращении вкладки.
  - Для оффлайна полагаться на `/session`, который возвращает накопленные награды.
- **Логирование**:
  - Перевести `POST /api/v1/tick` в `debug`.
  - Оставить `warn`/`error` только для аномалий (`auth_missing_header`, `invalid_token`, `tick_skip_unauthenticated`).

## Предложенные варианты решения

### Вариант A — «консервативный»
1. Перед `flushPassiveIncome` жёстко проверять флаг `authReady`.
2. Останавливать интервалы тика, когда вкладка скрыта; запускать разовый тик при возвращении.
3. Логи `/tick` перевести в `debug`, оставить `warn` для ошибок авторизации.

### Вариант B — «гибрид с initData»
1. Разрешить **первый** тик без JWT, но с заголовком `Authorization: TelegramInit <raw initData>`:
   - Бэкенд валидирует подпись initData (через `@telegram-apps/init-data-node`).
   - Сразу выдаёт новые `access/refresh` токены и выполняет тик.
2. После этого клиент работает по обычной схеме `Bearer`.
3. Также добавить паузы/хранение пассивки как в варианте A.

## Следующие шаги
- Определиться: достаточно ли варианта A (меньше изменений) или нужна мгновенная обработка initData (вариант B).
- Независимо от выбранного варианта:
  - Переквалифицировать логи `/tick` в `debug`.
  - Доделать на фронте блокировку flush, пока не получен токен.
  - Настроить повторный flush сразу после `authReady`, чтобы не терять накопленное время.
